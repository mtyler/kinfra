apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  dataDirHostPath: /var/lib/rook
  cephVersion:
    image: quay.io/ceph/ceph:v19
    allowUnsupported: true
  mon:
    count: 1
    allowMultiplePerNode: true
  mgr:
    count: 1
    allowMultiplePerNode: true
    modules:
    - name: rook
      enabled: true
  dashboard:
    enabled: true
  crashCollector:
    disable: true
  storage:
    useAllNodes: true
    useAllDevices: true
    allowDeviceClassUpdate: true
    allowOsdCrushWeightUpdate: false
  monitoring:
    enabled: true
  healthCheck:
    daemonHealth:
      mon:
        interval: 45s
        timeout: 600s
  priorityClassNames:
    all: system-node-critical
    mgr: system-cluster-critical
  disruptionManagement:
    managePodBudgets: true
  cephConfig:
    global:
      osd_pool_default_size: "1"
      mon_warn_on_pool_no_redundancy: "false"
      bdev_flock_retry: "20"
      bluefs_buffered_io: "false"
      mon_data_avail_warn: "10"
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-block
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
  clusterID: rook-ceph
  pool: replicapool
  imageFormat: "2"
  imageFeatures: layering
  csi.storage.k8s.io/provisioner-secret-name: rook-csi-rbd-provisioner
  csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph
  csi.storage.k8s.io/controller-expand-secret-name: rook-csi-rbd-provisioner
  csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph
  csi.storage.k8s.io/node-stage-secret-name: rook-csi-rbd-node
  csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph
  csi.storage.k8s.io/fstype: ext4
reclaimPolicy: Delete
allowVolumeExpansion: true
---
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: builtin-mgr
  namespace: rook-ceph
spec:
  name: .mgr
  replicated:
    size: 1
    requireSafeReplicaSize: false
---
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: replicapool
  namespace: rook-ceph
spec:
  failureDomain: osd
  replicated:
    size: 1
    requireSafeReplicaSize: false
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rook-ceph-tools-operator-image
  namespace: rook-ceph
  labels:
    app: rook-ceph-tools-operator-image
  annotations:
    deployment.kubernetes.io/revision: "1"
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"apps/v1","kind":"Deployment","metadata":{"annotations":{},"labels":{"app":"rook-ceph-tools-operator-image"},"name":"rook-ceph-tools-operator-image","namespace":"rook-ceph"},"spec":{"replicas":1,"selector":{"matchLabels":{"app":"rook-ceph-tools-operator-image"}},"template":{"metadata":{"labels":{"app":"rook-ceph-tools-operator-image"}},"spec":{"containers":[{"command":["/bin/bash","-c","# Replicate the script from toolbox.sh inline so the ceph image\n# can be run directly, instead of requiring the rook toolbox\nCEPH_CONFIG=\"/etc/ceph/ceph.conf\"\nMON_CONFIG=\"/etc/rook/mon-endpoints\"\nKEYRING_FILE=\"/etc/ceph/keyring\"\n\n# create a ceph config file in its default location so ceph/rados tools can be used\n# without specifying any arguments\nwrite_endpoints() {\n  endpoints=$(cat $${MON_CONFIG})\n\n  # filter out the mon names\n  # external cluster can have numbers or hyphens in mon names, handling them in regex\n  # shellcheck disable=SC2001\n  mon_endpoints=$(echo \"$${endpoints}\"| sed 's/[a-z0-9_-]\\+=//g')\n\n  DATE=$(date)\n  echo \"$DATE writing mon endpoints to $${CEPH_CONFIG}: $${endpoints}\"\n    cat <<EOF > $${CEPH_CONFIG}\n[global]\nmon_host = $${mon_endpoints}\n\n[client.admin]\nkeyring = $${KEYRING_FILE}\nEOF\n}\n\n# watch the endpoints config file and update if the mon endpoints ever change\nwatch_endpoints() {\n  # get the timestamp for the target of the soft link\n  real_path=$(realpath $${MON_CONFIG})\n  initial_time=$(stat -c %Z \"$${real_path}\")\n  while true; do\n    real_path=$(realpath $${MON_CONFIG})\n    latest_time=$(stat -c %Z \"$${real_path}\")\n\n    if [[ \"$${latest_time}\" != \"$${initial_time}\"...
spec:
  replicas: 1
  selector:
    matchLabels:
      app: rook-ceph-tools-operator-image
  template:
    metadata:
      labels:
        app: rook-ceph-tools-operator-image
    spec:
      containers:
      - name: rook-ceph-tools-operator-image
        image: docker.io/rook/ceph:master
        command:
        - /bin/bash
        - -c
        - |
          # Replicate the script from toolbox.sh inline so the ceph image
          # can be run directly, instead of requiring the rook toolbox
          CEPH_CONFIG="/etc/ceph/ceph.conf"
          MON_CONFIG="/etc/rook/mon-endpoints"
          KEYRING_FILE="/etc/ceph/keyring"

          # create a ceph config file in its default location so ceph/rados tools can be used
          # without specifying any arguments
          write_endpoints() {
            endpoints=$(cat $${MON_CONFIG})

            # filter out the mon names
            # external cluster can have numbers or hyphens in mon names, handling them in regex
            # shellcheck disable=SC2001
            mon_endpoints=$(echo "$${endpoints}"| sed 's/[a-z0-9_-]\\+=//g')

            DATE=$(date)
            echo "$DATE writing mon endpoints to $${CEPH_CONFIG}: $${endpoints}"
              cat <<EOF > $${CEPH_CONFIG}
          [global]
          mon_host = $${mon_endpoints}

          [client.admin]
          keyring = $${KEYRING_FILE}
          EOF
          }

          # watch the endpoints config file and update if the mon endpoints ever change
          watch_endpoints() {
            # get the timestamp for the target of the soft link
            real_path=$(realpath $${MON_CONFIG})
            initial_time=$(stat -c %Z "$${real_path}")
            while true; do
              real_path=$(realpath $${MON_CONFIG})
              latest_time=$(stat -c %Z "$${real_path}")

              if [[ "$${latest_time}" != "$${initial_time}" ]]; then
                write_endpoints
                initial_time=$${latest_time}
              fi

              sleep 10
            done
          }

          # read the secret from an env var (for backward compatibility), or from the secret file
          ceph_secret=$${ROOK_CEPH_SECRET}
          if [[ "$ceph_secret" == "" ]]; then
            ceph_secret=$(cat /var/lib/rook-ceph-mon/secret.keyring)
          fi

          # create the keyring file
          cat <<EOF > $${KEYRING_FILE}
          [$${ROOK_CEPH_USERNAME}]
          key = $${ceph_secret}
          EOF

          # write the initial config file
          write_endpoints

          # continuously update the mon endpoints if they fail over
          watch_endpoints
        env:
        - name: ROOK_CEPH_USERNAME
          valueFrom:
            secretKeyRef:
              name: rook-ceph-mon
              key: ceph-username
        volumeMounts:
        - name: ceph-config
          mountPath: /etc/ceph
        - name: mon-endpoint-volume
          mountPath: /etc/rook
        - name: ceph-admin-secret
          mountPath: /var/lib/rook-ceph-mon
          readOnly: true
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        imagePullPolicy: IfNotPresent
        securityContext:
          capabilities:
            drop:
            - ALL
          runAsUser: 2016
          runAsGroup: 2016
          runAsNonRoot: true
        tty: true
      volumes:
      - name: ceph-admin-secret
        secret:
          secretName: rook-ceph-mon
          items:
          - key: ceph-secret
            path: secret.keyring
          defaultMode: 644
      - name: mon-endpoint-volume
        configMap:
          name: rook-ceph-mon-endpoints
          items:
          - key: data
            path: mon-endpoints
          defaultMode: 644
      - name: ceph-config
        emptyDir: {}
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      dnsPolicy: ClusterFirstWithHostNet
      serviceAccountName: rook-ceph-default
      schedulerName: default-scheduler
      tolerations:
      - key: node.kubernetes.io/unreachable
        operator: Exists
        effect: NoExecute
        tolerationSeconds: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 25%
      maxSurge: 25%
  revisionHistoryLimit: 10
  progressDeadlineSeconds: 600
